{
    "sourceFile": "NIST-PQ-Submission-Kyber-20201001/Optimized_Implementation/crypto_kem/kyber512/forro_cipher-main/src/xote/ref/xote.c",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 3,
            "patches": [
                {
                    "date": 1715278224207,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1715278252055,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -225,8 +225,9 @@\n \n \n void xote_kdf(uint8_t *out, size_t outlen, uint8_t *in, size_t inlen)\n {\n+    int inicio = clock();\n     stream_ctx ctx = { 0x0 };\n     uint32_t iv[2] = { 0x0 };\n     size_t ctr = 0;\n \n"
                },
                {
                    "date": 1715278282144,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -254,6 +254,9 @@\n         xote_ivsetup_xor(&ctx, (uint8_t *)iv);\n     }\n  \n     xote_generate_bytes(&ctx, out, outlen);\n+    int intervalo = clock() - inicio;\n+    float tempo_ms = (float)intervalo/CLOCKS_PER_SEC *1000;\n+    registrar_resultado(tempo_ms, TOTAL_KDF_XOTE);\n     \n }\n"
                },
                {
                    "date": 1715282742007,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -219,9 +219,13 @@\n }\n \n void xote_squeeze(uint8_t *out, size_t outbytes, stream_ctx *ctx)\n {\n+    int inicio = clock();\n     xote_generate_bytes(ctx, out, outbytes);\n+    int intervalo = clock() - inicio;\n+    float tempo_ms = (float)intervalo/CLOCKS_PER_SEC *1000;\n+    registrar_resultado(tempo_ms, TOTAL_XOF_SQUEEZE_XOTE);\n }\n \n \n void xote_kdf(uint8_t *out, size_t outlen, uint8_t *in, size_t inlen)\n"
                }
            ],
            "date": 1715278224207,
            "name": "Commit-0",
            "content": "#include \"xote.h\"\n#include <stdio.h>\n#include <time.h>\n#include \"../../../../speed_print.h\"\n#include \"../../../../test_speed.h\"\n\n#pragma GCC optimize(\"O3\")\n#define rounds 7\n#define ROTL(a, b) (((a) << (b)) | ((a) >> (32 - (b))))\n#define Q(a, b, c, d, e) (                   \\\n    d += e, c ^= d, b += c, b = ROTL(b, 10), \\\n    a += b, e ^= a, d += e, d = ROTL(d, 27), \\\n    c += d, b ^= c, a += b, a = ROTL(a, 8))\n\ninline void xote(uint8_t out[128], const uint32_t init[16])\n{\n    uint32_t state_vector[16];\n    uint32_t state_vector2[16];\n    int i;\n    for (i = 0; i < 16; i++)\n    {\n        state_vector[i] = init[i];\n        state_vector2[i] = init[i];\n    }\n\n    state_vector2[4] = state_vector2[4] + 1;\n\n    xote_qr(state_vector, state_vector2);\n\n    for (i = 0; i < 16; i++)\n    {\n        state_vector[i] = init[i] + state_vector[i];\n        state_vector2[i] = init[i] + state_vector2[i];\n    }\n    state_vector2[4] = state_vector2[4] + 1;\n    for (i = 0; i < 16; i++)\n    {\n        U32TO8_LITTLE(out + 4 * i, state_vector[i]);\n        U32TO8_LITTLE(out + 4 * i + 64, state_vector2[i]);\n    }\n\n    return;\n}\n\ninline void xote_qr(uint32_t state_vector[16], uint32_t state_vector2[16])\n{\n    int i;\n\n    for (i = 0; i < rounds; i++)\n    {\n        Q(state_vector[0], state_vector[4], state_vector[8], state_vector[12], state_vector[3]);\n        Q(state_vector2[0], state_vector2[4], state_vector2[8], state_vector2[12], state_vector2[3]);\n        Q(state_vector[1], state_vector[5], state_vector[9], state_vector[13], state_vector[0]);\n        Q(state_vector2[1], state_vector2[5], state_vector2[9], state_vector2[13], state_vector2[0]);\n        Q(state_vector[2], state_vector[6], state_vector[10], state_vector[14], state_vector[1]);\n        Q(state_vector2[2], state_vector2[6], state_vector2[10], state_vector2[14], state_vector2[1]);\n        Q(state_vector[3], state_vector[7], state_vector[11], state_vector[15], state_vector[2]);\n        Q(state_vector2[3], state_vector2[7], state_vector2[11], state_vector2[15], state_vector2[2]);\n        Q(state_vector[0], state_vector[5], state_vector[10], state_vector[15], state_vector[3]);\n        Q(state_vector2[0], state_vector2[5], state_vector2[10], state_vector2[15], state_vector2[3]);\n        Q(state_vector[1], state_vector[6], state_vector[11], state_vector[12], state_vector[0]);\n        Q(state_vector2[1], state_vector2[6], state_vector2[11], state_vector2[12], state_vector2[0]);\n        Q(state_vector[2], state_vector[7], state_vector[8], state_vector[13], state_vector[1]);\n        Q(state_vector2[2], state_vector2[7], state_vector2[8], state_vector2[13], state_vector2[1]);\n        Q(state_vector[3], state_vector[4], state_vector[9], state_vector[14], state_vector[2]);\n        Q(state_vector2[3], state_vector2[4], state_vector2[9], state_vector2[14], state_vector2[2]);\n    }\n    return;\n}\n\nvoid xote_init()\n{\n    return;\n}\n\nvoid xote_keysetup(stream_ctx *x, uint8_t *key)\n{\n    x->state[0] = U8TO32_LITTLE(key + 0);\n    x->state[1] = U8TO32_LITTLE(key + 4);\n    x->state[2] = U8TO32_LITTLE(key + 8);\n    x->state[3] = U8TO32_LITTLE(key + 12);\n    x->state[6] = U8TO32_LITTLE(SIGMA + 0);\n    x->state[7] = U8TO32_LITTLE(SIGMA + 4);\n    x->state[8] = U8TO32_LITTLE(key + 16);\n    x->state[9] = U8TO32_LITTLE(key + 20);\n    x->state[10] = U8TO32_LITTLE(key + 24);\n    x->state[11] = U8TO32_LITTLE(key + 28);\n    x->state[14] = U8TO32_LITTLE(SIGMA + 8);\n    x->state[15] = U8TO32_LITTLE(SIGMA + 12);\n}\n\nvoid xote_ivsetup(stream_ctx *x, uint8_t *iv)\n{\n    x->state[4] = 0;\n    x->state[5] = 0;\n    x->state[12] = U8TO32_LITTLE(iv + 0);\n    x->state[13] = U8TO32_LITTLE(iv + 4);\n}\n\nvoid xote_keysetup_xor(stream_ctx *x, uint8_t *key)\n{\n    x->state[0] ^= U8TO32_LITTLE(key + 0);\n    x->state[1] ^= U8TO32_LITTLE(key + 4);\n    x->state[2] ^= U8TO32_LITTLE(key + 8);\n    x->state[3] ^= U8TO32_LITTLE(key + 12);\n    x->state[6] ^= U8TO32_LITTLE(SIGMA + 0);\n    x->state[7] ^= U8TO32_LITTLE(SIGMA + 4);\n    x->state[8] ^= U8TO32_LITTLE(key + 16);\n    x->state[9] ^= U8TO32_LITTLE(key + 20);\n    x->state[10] ^= U8TO32_LITTLE(key + 24);\n    x->state[11] ^= U8TO32_LITTLE(key + 28);\n    x->state[14] ^= U8TO32_LITTLE(SIGMA + 8);\n    x->state[15] ^= U8TO32_LITTLE(SIGMA + 12);\n}\n\nvoid xote_ivsetup_xor(stream_ctx *x, uint8_t *iv)\n{\n    x->state[4] ^= 0;\n    x->state[5] ^= 0;\n    x->state[12] ^= U8TO32_LITTLE(iv + 0);\n    x->state[13] ^= U8TO32_LITTLE(iv + 4);\n}\n\ninline void xote_encrypt_bytes(stream_ctx *x, const uint8_t *m, uint8_t *c, uint32_t bytes)\n{\n    uint8_t output[128];\n    int i;\n\n    if (!bytes)\n        return;\n    for (;;)\n    {\n        xote(output, x->state);\n        x->state[4] = x->state[4] + 2;\n        if (!(x->state[4] >> 1))\n        {\n            x->state[5] = x->state[5] + 1;\n        }\n        if (bytes <= 128)\n        {\n            for (i = 0; i < bytes; ++i)\n                c[i] = m[i] ^ output[i];\n            return;\n        }\n        for (i = 0; i < 128; ++i)\n            c[i] = m[i] ^ output[i];\n        bytes -= 128;\n        c += 128;\n        m += 128;\n    }\n}\n\ninline void xote_generate_bytes(stream_ctx *x, uint8_t *c, uint32_t bytes)\n{\n    uint8_t output[128];\n    int i;\n\n    if (!bytes)\n        return;\n    for (;;)\n    {\n        xote(output, x->state);\n        x->state[4] = x->state[4] + 2;\n        if (!(x->state[4] >> 1))\n        {\n            x->state[5] = x->state[5] + 1;\n        }\n        if (bytes <= 128)\n        {\n            for (i = 0; i < bytes; ++i)\n                c[i] = output[i];\n            return;\n        }\n        for (i = 0; i < 128; ++i)\n            c[i] = output[i];\n        bytes -= 128;\n        c += 128;\n    }\n}\n\nvoid xote_decrypt_bytes(stream_ctx *x, const uint8_t *c, uint8_t *m, uint32_t bytes)\n{\n    xote_encrypt_bytes(x, c, m, bytes);\n}\n\nvoid xote_keystream_bytes(stream_ctx *x, uint8_t *stream, uint32_t bytes)\n{\n    uint32_t i;\n    for (i = 0; i < bytes; ++i)\n        stream[i] = 0;\n    xote_encrypt_bytes(x, stream, stream, bytes);\n}\n\nvoid xote_prf(uint8_t *out, size_t outlen, const uint8_t key[KYBER_SYMBYTES], uint8_t * expnonce)\n{\n    int inicio = clock();\n\n    stream_ctx ctx;\n    xote_keysetup(&ctx, (uint8_t *)key);\n    uint8_t iv[8] = { 0 };\n    iv[0] = expnonce[0];\n    xote_ivsetup(&ctx, iv);\n    xote_keystream_bytes(&ctx, out, (uint32_t)outlen);\n\n    int intervalo = clock() - inicio;\n    float tempo_ms = (float)intervalo/CLOCKS_PER_SEC *1000;\n    registrar_resultado(tempo_ms, TOTAL_PRF_XOTE);\n}\n\nvoid xote_absorb(stream_ctx *ctx, const uint8_t *seed, uint8_t * expnonce)\n{\n    xote_keysetup(ctx, (uint8_t *)seed);\n    uint8_t iv[8] = { 0 };\n    iv[0] = expnonce[0];\n    iv[1] = expnonce[1];\n\n    xote_ivsetup(ctx, iv);\n    xote_qr(ctx->state, ctx->state);\n}\n\nvoid xote_squeeze(uint8_t *out, size_t outbytes, stream_ctx *ctx)\n{\n    xote_generate_bytes(ctx, out, outbytes);\n}\n\n\nvoid xote_kdf(uint8_t *out, size_t outlen, uint8_t *in, size_t inlen)\n{\n    stream_ctx ctx = { 0x0 };\n    uint32_t iv[2] = { 0x0 };\n    size_t ctr = 0;\n\n    while(inlen >= 32)\n    {\n        xote_keysetup_xor(&ctx, in);\n        xote_ivsetup_xor(&ctx, (uint8_t *)iv);\n\n        in += 32;\n        inlen -= 32;\n\n        iv[0]++;\n        if(!iv[0])\n            iv[1]++;\n    }\n\n    if(inlen)\n    {\n        uint8_t key_rem[32] = { 0x0 };\n        for(int i = 0; i < inlen; i++)\n            key_rem[i] = in[i];\n\n        xote_keysetup_xor(&ctx, key_rem);\n        xote_ivsetup_xor(&ctx, (uint8_t *)iv);\n    }\n \n    xote_generate_bytes(&ctx, out, outlen);\n    \n}\n"
        }
    ]
}