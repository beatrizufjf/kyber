{
    "sourceFile": "NIST-PQ-Submission-Kyber-20201001/Optimized_Implementation/crypto_kem/kyber512/fips202.c",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 3,
            "patches": [
                {
                    "date": 1715280832315,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1715280838993,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -8,8 +8,9 @@\n #include <stddef.h>\n #include <stdint.h>\n #include \"fips202.h\"\n #include \"test_speed.h\"\n+#include <time.h>\n \n #define NROUNDS 24\n #define ROL(a, offset) ((a << offset) ^ (a >> (64-offset)))\n \n"
                },
                {
                    "date": 1715280901978,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -524,8 +524,10 @@\n *              - size_t inlen:      length of input in bytes\n **************************************************/\n void shake256(uint8_t *out, size_t outlen, const uint8_t *in, size_t inlen)\n {\n+  int inicio = clock();\n+\n   unsigned int i;\n   size_t nblocks = outlen/SHAKE256_RATE;\n   uint8_t t[SHAKE256_RATE];\n   keccak_state state;\n@@ -540,8 +542,12 @@\n     shake256_squeezeblocks(t, 1, &state);\n     for(i=0;i<outlen;i++)\n       out[i] = t[i];\n   }\n+\n+  int intervalo = clock() - inicio;\n+  float tempo_ms = (float)intervalo/CLOCKS_PER_SEC *1000;\n+  registrar_resultado(tempo_ms, TOTAL_KDF_SHAKE);\n }\n \n /*************************************************\n * Name:        sha3_256\n"
                },
                {
                    "date": 1715283060960,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -447,9 +447,13 @@\n *              - keccak_state *s: pointer to input/output Keccak state\n **************************************************/\n void shake128_squeezeblocks(uint8_t *out, size_t nblocks, keccak_state *state)\n {\n+  int inicio = clock();\n   keccak_squeezeblocks(out, nblocks, state->s, SHAKE128_RATE);\n+  int intervalo = clock() - inicio;\n+  float tempo_ms = (float)intervalo/CLOCKS_PER_SEC *1000;\n+  registrar_resultado(tempo_ms, TOTAL_XOF_SQUEEZE_SHAKE);\n }\n \n /*************************************************\n * Name:        shake256_absorb\n"
                }
            ],
            "date": 1715280832315,
            "name": "Commit-0",
            "content": "/* Based on the public domain implementation in\n * crypto_hash/keccakc512/simple/ from http://bench.cr.yp.to/supercop.html\n * by Ronny Van Keer\n * and the public domain \"TweetFips202\" implementation\n * from https://twitter.com/tweetfips202\n * by Gilles Van Assche, Daniel J. Bernstein, and Peter Schwabe */\n\n#include <stddef.h>\n#include <stdint.h>\n#include \"fips202.h\"\n#include \"test_speed.h\"\n\n#define NROUNDS 24\n#define ROL(a, offset) ((a << offset) ^ (a >> (64-offset)))\n\n/*************************************************\n* Name:        load64\n*\n* Description: Load 8 bytes into uint64_t in little-endian order\n*\n* Arguments:   - const uint8_t *x: pointer to input byte array\n*\n* Returns the loaded 64-bit unsigned integer\n**************************************************/\nstatic uint64_t load64(const uint8_t x[8]) {\n  unsigned int i;\n  uint64_t r = 0;\n\n  for(i=0;i<8;i++)\n    r |= (uint64_t)x[i] << 8*i;\n\n  return r;\n}\n\n/*************************************************\n* Name:        store64\n*\n* Description: Store a 64-bit integer to array of 8 bytes in little-endian order\n*\n* Arguments:   - uint8_t *x: pointer to the output byte array (allocated)\n*              - uint64_t u: input 64-bit unsigned integer\n**************************************************/\nstatic void store64(uint8_t x[8], uint64_t u) {\n  unsigned int i;\n\n  for(i=0;i<8;i++)\n    x[i] = u >> 8*i;\n}\n\n/* Keccak round constants */\nstatic const uint64_t KeccakF_RoundConstants[NROUNDS] = {\n  (uint64_t)0x0000000000000001ULL,\n  (uint64_t)0x0000000000008082ULL,\n  (uint64_t)0x800000000000808aULL,\n  (uint64_t)0x8000000080008000ULL,\n  (uint64_t)0x000000000000808bULL,\n  (uint64_t)0x0000000080000001ULL,\n  (uint64_t)0x8000000080008081ULL,\n  (uint64_t)0x8000000000008009ULL,\n  (uint64_t)0x000000000000008aULL,\n  (uint64_t)0x0000000000000088ULL,\n  (uint64_t)0x0000000080008009ULL,\n  (uint64_t)0x000000008000000aULL,\n  (uint64_t)0x000000008000808bULL,\n  (uint64_t)0x800000000000008bULL,\n  (uint64_t)0x8000000000008089ULL,\n  (uint64_t)0x8000000000008003ULL,\n  (uint64_t)0x8000000000008002ULL,\n  (uint64_t)0x8000000000000080ULL,\n  (uint64_t)0x000000000000800aULL,\n  (uint64_t)0x800000008000000aULL,\n  (uint64_t)0x8000000080008081ULL,\n  (uint64_t)0x8000000000008080ULL,\n  (uint64_t)0x0000000080000001ULL,\n  (uint64_t)0x8000000080008008ULL\n};\n\n/*************************************************\n* Name:        KeccakF1600_StatePermute\n*\n* Description: The Keccak F1600 Permutation\n*\n* Arguments:   - uint64_t *state: pointer to input/output Keccak state\n**************************************************/\nstatic void KeccakF1600_StatePermute(uint64_t state[25])\n{\n        int round;\n\n        uint64_t Aba, Abe, Abi, Abo, Abu;\n        uint64_t Aga, Age, Agi, Ago, Agu;\n        uint64_t Aka, Ake, Aki, Ako, Aku;\n        uint64_t Ama, Ame, Ami, Amo, Amu;\n        uint64_t Asa, Ase, Asi, Aso, Asu;\n        uint64_t BCa, BCe, BCi, BCo, BCu;\n        uint64_t Da, De, Di, Do, Du;\n        uint64_t Eba, Ebe, Ebi, Ebo, Ebu;\n        uint64_t Ega, Ege, Egi, Ego, Egu;\n        uint64_t Eka, Eke, Eki, Eko, Eku;\n        uint64_t Ema, Eme, Emi, Emo, Emu;\n        uint64_t Esa, Ese, Esi, Eso, Esu;\n\n        //copyFromState(A, state)\n        Aba = state[ 0];\n        Abe = state[ 1];\n        Abi = state[ 2];\n        Abo = state[ 3];\n        Abu = state[ 4];\n        Aga = state[ 5];\n        Age = state[ 6];\n        Agi = state[ 7];\n        Ago = state[ 8];\n        Agu = state[ 9];\n        Aka = state[10];\n        Ake = state[11];\n        Aki = state[12];\n        Ako = state[13];\n        Aku = state[14];\n        Ama = state[15];\n        Ame = state[16];\n        Ami = state[17];\n        Amo = state[18];\n        Amu = state[19];\n        Asa = state[20];\n        Ase = state[21];\n        Asi = state[22];\n        Aso = state[23];\n        Asu = state[24];\n\n        for( round = 0; round < NROUNDS; round += 2 )\n        {\n            //    prepareTheta\n            BCa = Aba^Aga^Aka^Ama^Asa;\n            BCe = Abe^Age^Ake^Ame^Ase;\n            BCi = Abi^Agi^Aki^Ami^Asi;\n            BCo = Abo^Ago^Ako^Amo^Aso;\n            BCu = Abu^Agu^Aku^Amu^Asu;\n\n            //thetaRhoPiChiIotaPrepareTheta(round  , A, E)\n            Da = BCu^ROL(BCe, 1);\n            De = BCa^ROL(BCi, 1);\n            Di = BCe^ROL(BCo, 1);\n            Do = BCi^ROL(BCu, 1);\n            Du = BCo^ROL(BCa, 1);\n\n            Aba ^= Da;\n            BCa = Aba;\n            Age ^= De;\n            BCe = ROL(Age, 44);\n            Aki ^= Di;\n            BCi = ROL(Aki, 43);\n            Amo ^= Do;\n            BCo = ROL(Amo, 21);\n            Asu ^= Du;\n            BCu = ROL(Asu, 14);\n            Eba =   BCa ^((~BCe)&  BCi );\n            Eba ^= (uint64_t)KeccakF_RoundConstants[round];\n            Ebe =   BCe ^((~BCi)&  BCo );\n            Ebi =   BCi ^((~BCo)&  BCu );\n            Ebo =   BCo ^((~BCu)&  BCa );\n            Ebu =   BCu ^((~BCa)&  BCe );\n\n            Abo ^= Do;\n            BCa = ROL(Abo, 28);\n            Agu ^= Du;\n            BCe = ROL(Agu, 20);\n            Aka ^= Da;\n            BCi = ROL(Aka,  3);\n            Ame ^= De;\n            BCo = ROL(Ame, 45);\n            Asi ^= Di;\n            BCu = ROL(Asi, 61);\n            Ega =   BCa ^((~BCe)&  BCi );\n            Ege =   BCe ^((~BCi)&  BCo );\n            Egi =   BCi ^((~BCo)&  BCu );\n            Ego =   BCo ^((~BCu)&  BCa );\n            Egu =   BCu ^((~BCa)&  BCe );\n\n            Abe ^= De;\n            BCa = ROL(Abe,  1);\n            Agi ^= Di;\n            BCe = ROL(Agi,  6);\n            Ako ^= Do;\n            BCi = ROL(Ako, 25);\n            Amu ^= Du;\n            BCo = ROL(Amu,  8);\n            Asa ^= Da;\n            BCu = ROL(Asa, 18);\n            Eka =   BCa ^((~BCe)&  BCi );\n            Eke =   BCe ^((~BCi)&  BCo );\n            Eki =   BCi ^((~BCo)&  BCu );\n            Eko =   BCo ^((~BCu)&  BCa );\n            Eku =   BCu ^((~BCa)&  BCe );\n\n            Abu ^= Du;\n            BCa = ROL(Abu, 27);\n            Aga ^= Da;\n            BCe = ROL(Aga, 36);\n            Ake ^= De;\n            BCi = ROL(Ake, 10);\n            Ami ^= Di;\n            BCo = ROL(Ami, 15);\n            Aso ^= Do;\n            BCu = ROL(Aso, 56);\n            Ema =   BCa ^((~BCe)&  BCi );\n            Eme =   BCe ^((~BCi)&  BCo );\n            Emi =   BCi ^((~BCo)&  BCu );\n            Emo =   BCo ^((~BCu)&  BCa );\n            Emu =   BCu ^((~BCa)&  BCe );\n\n            Abi ^= Di;\n            BCa = ROL(Abi, 62);\n            Ago ^= Do;\n            BCe = ROL(Ago, 55);\n            Aku ^= Du;\n            BCi = ROL(Aku, 39);\n            Ama ^= Da;\n            BCo = ROL(Ama, 41);\n            Ase ^= De;\n            BCu = ROL(Ase,  2);\n            Esa =   BCa ^((~BCe)&  BCi );\n            Ese =   BCe ^((~BCi)&  BCo );\n            Esi =   BCi ^((~BCo)&  BCu );\n            Eso =   BCo ^((~BCu)&  BCa );\n            Esu =   BCu ^((~BCa)&  BCe );\n\n            //    prepareTheta\n            BCa = Eba^Ega^Eka^Ema^Esa;\n            BCe = Ebe^Ege^Eke^Eme^Ese;\n            BCi = Ebi^Egi^Eki^Emi^Esi;\n            BCo = Ebo^Ego^Eko^Emo^Eso;\n            BCu = Ebu^Egu^Eku^Emu^Esu;\n\n            //thetaRhoPiChiIotaPrepareTheta(round+1, E, A)\n            Da = BCu^ROL(BCe, 1);\n            De = BCa^ROL(BCi, 1);\n            Di = BCe^ROL(BCo, 1);\n            Do = BCi^ROL(BCu, 1);\n            Du = BCo^ROL(BCa, 1);\n\n            Eba ^= Da;\n            BCa = Eba;\n            Ege ^= De;\n            BCe = ROL(Ege, 44);\n            Eki ^= Di;\n            BCi = ROL(Eki, 43);\n            Emo ^= Do;\n            BCo = ROL(Emo, 21);\n            Esu ^= Du;\n            BCu = ROL(Esu, 14);\n            Aba =   BCa ^((~BCe)&  BCi );\n            Aba ^= (uint64_t)KeccakF_RoundConstants[round+1];\n            Abe =   BCe ^((~BCi)&  BCo );\n            Abi =   BCi ^((~BCo)&  BCu );\n            Abo =   BCo ^((~BCu)&  BCa );\n            Abu =   BCu ^((~BCa)&  BCe );\n\n            Ebo ^= Do;\n            BCa = ROL(Ebo, 28);\n            Egu ^= Du;\n            BCe = ROL(Egu, 20);\n            Eka ^= Da;\n            BCi = ROL(Eka, 3);\n            Eme ^= De;\n            BCo = ROL(Eme, 45);\n            Esi ^= Di;\n            BCu = ROL(Esi, 61);\n            Aga =   BCa ^((~BCe)&  BCi );\n            Age =   BCe ^((~BCi)&  BCo );\n            Agi =   BCi ^((~BCo)&  BCu );\n            Ago =   BCo ^((~BCu)&  BCa );\n            Agu =   BCu ^((~BCa)&  BCe );\n\n            Ebe ^= De;\n            BCa = ROL(Ebe, 1);\n            Egi ^= Di;\n            BCe = ROL(Egi, 6);\n            Eko ^= Do;\n            BCi = ROL(Eko, 25);\n            Emu ^= Du;\n            BCo = ROL(Emu, 8);\n            Esa ^= Da;\n            BCu = ROL(Esa, 18);\n            Aka =   BCa ^((~BCe)&  BCi );\n            Ake =   BCe ^((~BCi)&  BCo );\n            Aki =   BCi ^((~BCo)&  BCu );\n            Ako =   BCo ^((~BCu)&  BCa );\n            Aku =   BCu ^((~BCa)&  BCe );\n\n            Ebu ^= Du;\n            BCa = ROL(Ebu, 27);\n            Ega ^= Da;\n            BCe = ROL(Ega, 36);\n            Eke ^= De;\n            BCi = ROL(Eke, 10);\n            Emi ^= Di;\n            BCo = ROL(Emi, 15);\n            Eso ^= Do;\n            BCu = ROL(Eso, 56);\n            Ama =   BCa ^((~BCe)&  BCi );\n            Ame =   BCe ^((~BCi)&  BCo );\n            Ami =   BCi ^((~BCo)&  BCu );\n            Amo =   BCo ^((~BCu)&  BCa );\n            Amu =   BCu ^((~BCa)&  BCe );\n\n            Ebi ^= Di;\n            BCa = ROL(Ebi, 62);\n            Ego ^= Do;\n            BCe = ROL(Ego, 55);\n            Eku ^= Du;\n            BCi = ROL(Eku, 39);\n            Ema ^= Da;\n            BCo = ROL(Ema, 41);\n            Ese ^= De;\n            BCu = ROL(Ese, 2);\n            Asa =   BCa ^((~BCe)&  BCi );\n            Ase =   BCe ^((~BCi)&  BCo );\n            Asi =   BCi ^((~BCo)&  BCu );\n            Aso =   BCo ^((~BCu)&  BCa );\n            Asu =   BCu ^((~BCa)&  BCe );\n        }\n\n        //copyToState(state, A)\n        state[ 0] = Aba;\n        state[ 1] = Abe;\n        state[ 2] = Abi;\n        state[ 3] = Abo;\n        state[ 4] = Abu;\n        state[ 5] = Aga;\n        state[ 6] = Age;\n        state[ 7] = Agi;\n        state[ 8] = Ago;\n        state[ 9] = Agu;\n        state[10] = Aka;\n        state[11] = Ake;\n        state[12] = Aki;\n        state[13] = Ako;\n        state[14] = Aku;\n        state[15] = Ama;\n        state[16] = Ame;\n        state[17] = Ami;\n        state[18] = Amo;\n        state[19] = Amu;\n        state[20] = Asa;\n        state[21] = Ase;\n        state[22] = Asi;\n        state[23] = Aso;\n        state[24] = Asu;\n}\n\n/*************************************************\n* Name:        keccak_absorb\n*\n* Description: Absorb step of Keccak;\n*              non-incremental, starts by zeroeing the state.\n*\n* Arguments:   - uint64_t *s: pointer to (uninitialized) output Keccak state\n*              - unsigned int r: rate in bytes (e.g., 168 for SHAKE128)\n*              - const uint8_t *m: pointer to input to be absorbed into s\n*              - size_t mlen: length of input in bytes\n*              - uint8_t p: domain-separation byte for different\n*                           Keccak-derived functions\n**************************************************/\nstatic void keccak_absorb(uint64_t s[25],\n                          unsigned int r,\n                          const uint8_t *m,\n                          size_t mlen,\n                          uint8_t p)\n{\n  size_t i;\n  uint8_t t[200] = {0};\n\n  /* Zero state */\n  for(i=0;i<25;i++)\n    s[i] = 0;\n\n  while(mlen >= r) {\n    for(i=0;i<r/8;i++)\n      s[i] ^= load64(m + 8*i);\n\n    KeccakF1600_StatePermute(s);\n    mlen -= r;\n    m += r;\n  }\n\n  for(i=0;i<mlen;i++)\n    t[i] = m[i];\n  t[i] = p;\n  t[r-1] |= 128;\n  for(i=0;i<r/8;i++)\n    s[i] ^= load64(t + 8*i);\n}\n\n/*************************************************\n* Name:        keccak_squeezeblocks\n*\n* Description: Squeeze step of Keccak. Squeezes full blocks of r bytes each.\n*              Modifies the state. Can be called multiple times to keep\n*              squeezing, i.e., is incremental.\n*\n* Arguments:   - uint8_t *h: pointer to output blocks\n*              - size_t nblocks: number of blocks to be squeezed (written to h)\n*              - uint64_t *s: pointer to input/output Keccak state\n*              - unsigned int r: rate in bytes (e.g., 168 for SHAKE128)\n**************************************************/\nstatic void keccak_squeezeblocks(uint8_t *out,\n                                 size_t nblocks,\n                                 uint64_t s[25],\n                                 unsigned int r)\n{\n  unsigned int i;\n  while(nblocks > 0) {\n    KeccakF1600_StatePermute(s);\n    for(i=0;i<r/8;i++)\n      store64(out + 8*i, s[i]);\n    out += r;\n    --nblocks;\n  }\n}\n\n/*************************************************\n* Name:        shake128_absorb\n*\n* Description: Absorb step of the SHAKE128 XOF.\n*              non-incremental, starts by zeroeing the state.\n*\n* Arguments:   - keccak_state *state: pointer to (uninitialized) output\n*                                     Keccak state\n*              - const uint8_t *in:   pointer to input to be absorbed into s\n*              - size_t inlen:        length of input in bytes\n**************************************************/\nvoid shake128_absorb(keccak_state *state, const uint8_t *in, size_t inlen)\n{\n  keccak_absorb(state->s, SHAKE128_RATE, in, inlen, 0x1F);\n}\n\n/*************************************************\n* Name:        shake128_squeezeblocks\n*\n* Description: Squeeze step of SHAKE128 XOF. Squeezes full blocks of\n*              SHAKE128_RATE bytes each. Modifies the state. Can be called\n*              multiple times to keep squeezing, i.e., is incremental.\n*\n* Arguments:   - uint8_t *out:    pointer to output blocks\n*              - size_t nblocks:  number of blocks to be squeezed\n*                                 (written to output)\n*              - keccak_state *s: pointer to input/output Keccak state\n**************************************************/\nvoid shake128_squeezeblocks(uint8_t *out, size_t nblocks, keccak_state *state)\n{\n  keccak_squeezeblocks(out, nblocks, state->s, SHAKE128_RATE);\n}\n\n/*************************************************\n* Name:        shake256_absorb\n*\n* Description: Absorb step of the SHAKE256 XOF.\n*              non-incremental, starts by zeroeing the state.\n*\n* Arguments:   - keccak_state *s:   pointer to (uninitialized) output Keccak state\n*              - const uint8_t *in: pointer to input to be absorbed into s\n*              - size_t inlen:      length of input in bytes\n**************************************************/\nvoid shake256_absorb(keccak_state *state, const uint8_t *in, size_t inlen)\n{\n  keccak_absorb(state->s, SHAKE256_RATE, in, inlen, 0x1F);\n}\n\n/*************************************************\n* Name:        shake256_squeezeblocks\n*\n* Description: Squeeze step of SHAKE256 XOF. Squeezes full blocks of\n*              SHAKE256_RATE bytes each. Modifies the state. Can be called\n*              multiple times to keep squeezing, i.e., is incremental.\n*\n* Arguments:   - uint8_t *out:    pointer to output blocks\n*              - size_t nblocks:  number of blocks to be squeezed\n*                                 (written to output)\n*              - keccak_State *s: pointer to input/output Keccak state\n**************************************************/\nvoid shake256_squeezeblocks(uint8_t *out, size_t nblocks, keccak_state *state)\n{\n  keccak_squeezeblocks(out, nblocks, state->s, SHAKE256_RATE);\n}\n\n/*************************************************\n* Name:        shake128\n*\n* Description: SHAKE128 XOF with non-incremental API\n*\n* Arguments:   - uint8_t *out:      pointer to output\n*              - size_t outlen:     requested output length in bytes\n*              - const uint8_t *in: pointer to input\n*              - size_t inlen:      length of input in bytes\n**************************************************/\nvoid shake128(uint8_t *out, size_t outlen, const uint8_t *in, size_t inlen)\n{\n  unsigned int i;\n  size_t nblocks = outlen/SHAKE128_RATE;\n  uint8_t t[SHAKE128_RATE];\n  keccak_state state;\n\n  shake128_absorb(&state, in, inlen);\n  shake128_squeezeblocks(out, nblocks, &state);\n\n  out += nblocks*SHAKE128_RATE;\n  outlen -= nblocks*SHAKE128_RATE;\n\n  if(outlen) {\n    shake128_squeezeblocks(t, 1, &state);\n    for(i=0;i<outlen;i++)\n      out[i] = t[i];\n  }\n}\n\n/*************************************************\n* Name:        shake256\n*\n* Description: SHAKE256 XOF with non-incremental API\n*\n* Arguments:   - uint8_t *out:      pointer to output\n*              - size_t outlen:     requested output length in bytes\n*              - const uint8_t *in: pointer to input\n*              - size_t inlen:      length of input in bytes\n**************************************************/\nvoid shake256(uint8_t *out, size_t outlen, const uint8_t *in, size_t inlen)\n{\n  unsigned int i;\n  size_t nblocks = outlen/SHAKE256_RATE;\n  uint8_t t[SHAKE256_RATE];\n  keccak_state state;\n\n  shake256_absorb(&state, in, inlen);\n  shake256_squeezeblocks(out, nblocks, &state);\n\n  out += nblocks*SHAKE256_RATE;\n  outlen -= nblocks*SHAKE256_RATE;\n\n  if(outlen) {\n    shake256_squeezeblocks(t, 1, &state);\n    for(i=0;i<outlen;i++)\n      out[i] = t[i];\n  }\n}\n\n/*************************************************\n* Name:        sha3_256\n*\n* Description: SHA3-256 with non-incremental API\n*\n* Arguments:   - uint8_t *h:        pointer to output (32 bytes)\n*              - const uint8_t *in: pointer to input\n*              - size_t inlen:      length of input in bytes\n**************************************************/\nvoid sha3_256(uint8_t h[32], const uint8_t *in, size_t inlen)\n{\n  unsigned int i;\n  uint64_t s[25];\n  uint8_t t[SHA3_256_RATE];\n\n  keccak_absorb(s, SHA3_256_RATE, in, inlen, 0x06);\n  keccak_squeezeblocks(t, 1, s, SHA3_256_RATE);\n\n  for(i=0;i<32;i++)\n    h[i] = t[i];\n}\n\n/*************************************************\n* Name:        sha3_512\n*\n* Description: SHA3-512 with non-incremental API\n*\n* Arguments:   - uint8_t *h:        pointer to output (64 bytes)\n*              - const uint8_t *in: pointer to input\n*              - size_t inlen:      length of input in bytes\n**************************************************/\nvoid sha3_512(uint8_t *h, const uint8_t *in, size_t inlen)\n{\n  unsigned int i;\n  uint64_t s[25];\n  uint8_t t[SHA3_512_RATE];\n\n  keccak_absorb(s, SHA3_512_RATE, in, inlen, 0x06);\n  keccak_squeezeblocks(t, 1, s, SHA3_512_RATE);\n\n  for(i=0;i<64;i++)\n    h[i] = t[i];\n}\n"
        }
    ]
}